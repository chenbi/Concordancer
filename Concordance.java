import java.util.*;
import java.io.*;

/* Author: Chen Bi 
 * Parallel Concordancer
 * Each thread finds the concordance of one different part of document, and adds the result to a word map. 
 * All the word maps from each thread is consolidated into one final word map
 * 
 * The concordancer assumes that the input text file is properly formated,
 * case like: "I love Java.And you?" where there's no space between two sentences is not covered
 */

public class Concordance {

	private static int NUM_THREAD = 4; //Number of threads, each thread processes part of the document

	private TreeMap<String, IWord> wordMap = new TreeMap<String, IWord>(); //a treemap stores {word, frequency and sentence numbers} pairs

	private StringBuilder document; //input file

	private int length; //length of entire document

	public Concordance(String fileName) {

		try {
			readFile(fileName); //read the text file into memory
		} catch (IOException e) {
			System.out.println("Error Reading File");
			e.printStackTrace();
		}

		int offset = (length-1) / NUM_THREAD; //split the document into number of threads, offset is the length of each part
		int remainder = (length-1) % NUM_THREAD; //remainder to be added to the last thread to process
		int beginIndex = 0; //begin index of document in each thread
		int endIndex = offset + beginIndex;//end index of document in each thread

		Vector<Thread> threads = new Vector<Thread>();//thread pool
		List <TreeMap<String, IWord>> mapList = new LinkedList<TreeMap<String, IWord>>();//list of treemaps, one treemap for one thread
		
		for (int i = 0; i < NUM_THREAD; i++) {

			while (!(Character.isWhitespace(document.charAt(endIndex)) && Character.isUpperCase(endIndex + 1) && document.charAt(endIndex - 1) == '.') && endIndex < length-2){ 
				endIndex++; //in case endIndex points to inside of a word, increment it to end of word by looking for whitespace
			}
			
			TreeMap<String, IWord> subMap = new TreeMap<String, IWord>();  //create a sub word map for new thread
			
			Thread concordancer = new ConcordancerThread(subMap, beginIndex, endIndex, document);//create a thread to process part of document
			concordancer.start();
			
			mapList.add(subMap);
			threads.add(concordancer);//add thread to thread pool

			beginIndex = endIndex;//increment beginIndex to the beginning of next part of document
			
			if (endIndex + offset + remainder< length - 1)
				endIndex = endIndex + offset; //increment endIndex to end of next part of document
			else
				endIndex = length - 2;//has reached end
			
		}
		

		for (int i = 0; i < threads.size(); i++)
			try {
				threads.get(i).join(); //wait for all threads finishing processing
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		
		consolidateConcordance(mapList, wordMap); //merge sub treemaps generated by each thread to a final wordmap
		
		printConcordance(); //print results
	}

	
	
	
	private void consolidateConcordance(List<TreeMap<String, IWord>> mapList,TreeMap<String, IWord> wordMap) {
		
		int [] maxSenNum = new int[NUM_THREAD]; //store the ending sentence number in each sub map
		for (int i = 0;i<NUM_THREAD;i++) maxSenNum[i]=0;  //initialization
		
		for (int i=0; i<NUM_THREAD;i++){ //loop through each sub treemap
			
			for (IWord word:mapList.get(i).values()){ //loop through each word in sub treemap
				
				IWord finalIWord = new Word(word.getWord()); //created a word to be stored in merged final wordmap
				
				if (wordMap.containsKey(word.getWord())) //check if final wordmap already has it
					finalIWord = wordMap.get(word.getWord());
				
				for (Integer j: word.getSentenceNum()){
					if (i==0)
						finalIWord.addSentenceNum(j); //store sentence number into finalIWord			
					else
						finalIWord.addSentenceNum(j + maxSenNum[i-1]); //add the ending sentence number from proceeding sub tree map to sentence number, and store to finalIWord	
					
					if(j>maxSenNum[i])							
						maxSenNum[i]=j; //update the ending sentence number in each sub map
				}

				finalIWord.addFrequency(word.getFrequency());
				wordMap.put(finalIWord.getWord(), finalIWord); // put word in word map
			}
		}
	}

	private void printConcordance() {
		
		int count = 0;
		for (String s : wordMap.keySet()) {//loop through each word in word map
			IWord word = wordMap.get(s);
			String sentenceNum = word.getSentenceNum().toString(); //convert list of sentence numbers to string
			sentenceNum = sentenceNum.replaceAll("\\s", "").replaceAll("^\\[|\\]$", ""); //remove white spaces and square brackets

			Formatter formatter = new Formatter();
			System.out.println(formatter.format("%-6s %-15s %-15s",
					printOrder(count) + ".",  
					s, "{" + 
					word.getFrequency()	+ ":" + sentenceNum + "}"));
			count++;
		}
	}

	private String printOrder(int count) {
		StringBuilder order = new StringBuilder();
		int remainder = (count) % 26;
		char alphabet = (char) (remainder + 97); // match the remainder to an alphabet by adding 97 to ASCII 'a'
		for (int i = count / 26; i >= 0; i--) {
			order.append(alphabet); 
		}
		return order.toString();
	}
	
	private void readFile(String fileName) throws IOException {

		File file = new File(fileName);
		document = new StringBuilder();
		Scanner scanner = new Scanner(file);
		while (scanner.hasNext())
			document.append(scanner.nextLine());
		
		scanner.close();
		length = document.length();
	}

	public static void main(String args[]) {
		 if(args.length == 0){
			 System.out.println("Please specify filename of text document");
		 }		
		 String fileName = args[0];
		 new Concordance(fileName);

	}

}
